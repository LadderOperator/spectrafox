Imports System.ComponentModel

Public Class cSpectroscopyTable
    Inherits EventArgs

#Region "DataColumn-SubClass"
    ''' <summary>
    ''' Represents a Column in a Spectroscopy Data-Table
    ''' </summary>
    Public Class DataColumn

#Region "Informative Properties"
        ''' <summary>
        ''' Represents the Column-Header
        ''' </summary>
        Public Property Name As String = ""

        ''' <summary>
        ''' Represents the Unit of the Values saved in the Column
        ''' </summary>
        Public Property UnitType As cUnits.UnitType

        ''' <summary>
        ''' Represents the Symbol of the Unit.
        ''' </summary>
        Public Property UnitSymbol As String = ""

        ''' <summary>
        ''' Is this column originally contained in the data file,
        ''' or generated by SpectraFox.
        ''' </summary>
        Public Property IsSpectraFoxGenerated As Boolean = True

        ''' <summary>
        ''' Returns the Formatted Axis-Title
        ''' </summary>
        Public ReadOnly Property AxisTitle As String
            Get
                Return Me.Name & " (" & Me.UnitSymbol & ")"
            End Get
        End Property

        ''' <summary>
        ''' Stores the data for this column.
        ''' </summary>
        Protected _Values As New List(Of Double)

        ''' <summary>
        ''' Contains the column-data.
        ''' Returns the cropped list.
        ''' </summary>
        Public Function Values(Optional ByVal ReturnFullData As Boolean = False) As ObjectModel.ReadOnlyCollection(Of Double)

            ' Shall we return the full data?
            If ReturnFullData Then
                Return Me._Values.AsReadOnly
            End If

            ' Check the crop informations
            Dim MinIndex As Integer = 0
            Dim MaxIndex As Integer = Me._Values.Count

            ' Set the indices from the crop informations.
            If Me.CurrentCropInformation.MinIndexIncl > 0 And Me.CurrentCropInformation.MinIndexIncl < Me._Values.Count Then
                MinIndex = Me.CurrentCropInformation.MinIndexIncl
            End If
            If Me.CurrentCropInformation.MaxIndexIncl > 0 And Me.CurrentCropInformation.MaxIndexIncl < Me._Values.Count Then
                MaxIndex = Me.CurrentCropInformation.MaxIndexIncl + 1
            End If

            ' Check, if MinIndex < MaxIndex
            If MinIndex > MaxIndex Then
                Dim tmp As Integer = MinIndex
                MinIndex = MaxIndex
                MaxIndex = tmp
            End If

            ' Create the cropped return-list.
            Dim ReturnList As New List(Of Double)(Me._Values.Count)

            ' Add NaN to the beginning.
            If MinIndex > 0 Then
                ReturnList.AddRange(Enumerable.Repeat(Of Double)(Double.NaN, MinIndex))
            End If
            ' Add the values in between.
            If MaxIndex <> MinIndex Then
                ReturnList.AddRange(Me._Values.GetRange(MinIndex, (MaxIndex - MinIndex)))
            End If
            ' Add NaN to the end.
            If MaxIndex < Me._Values.Count Then
                ReturnList.AddRange(Enumerable.Repeat(Of Double)(Double.NaN, (Me._Values.Count - MaxIndex)))
            End If

            Return ReturnList.AsReadOnly
        End Function

        ''' <summary>
        ''' Variable that stored the expected length of the column.
        ''' </summary>
        Private _ExpectedValueCount As Integer = 0

        ''' <summary>
        ''' Returns the count of values in the column,
        ''' if the column is not empty. If it IS empty, then
        ''' it returns the value stored in _ExpectedValueCount.
        ''' 
        ''' Set: Only sets the expected value count.
        ''' </summary>
        Public Property ValueCount As Integer
            Get
                If Me._Values.Count <= 0 Then
                    Return Me._ExpectedValueCount
                Else
                    Return Me._Values.Count
                End If
            End Get
            Set(value As Integer)
                Me._ExpectedValueCount = value
            End Set
        End Property

        ''' <summary>
        ''' Sets the data stored in this column.
        ''' Resets all crop information.
        ''' </summary>
        Public Sub SetValueList(ByRef ValueList As List(Of Double))
            Me._Values = ValueList
        End Sub

        ''' <summary>
        ''' Adds a value to the column.
        ''' Function used in the import routine.
        ''' </summary>
        Public Sub AddValueToColumn(ByVal Value As Double)
            Me._Values.Add(Value)
        End Sub

        ''' <summary>
        ''' Sets a value in the data list of this column.
        ''' </summary>
        Public Sub SetValueInColumn(ByVal Index As Integer, ByVal Value As Double)
            Me._Values(Index) = Value
        End Sub

        Private _CurrentCropInformation As CropInformation
        ''' <summary>
        ''' Sets/gets the crop information for this data column.
        ''' For values smaller 0, the data is not cropped!
        ''' </summary>
        Public Property CurrentCropInformation As CropInformation
            Get
                If Me._CurrentCropInformation = Nothing Then
                    Return New CropInformation(0, Me.ValueCount - 1)
                Else
                    Return Me._CurrentCropInformation
                End If
            End Get
            Set(value As CropInformation)
                Me._CurrentCropInformation = value
            End Set
        End Property


#End Region

#Region "Value-Modification"
        ''' <summary>
        ''' Shifts the DataValues by a given Value
        ''' </summary>
        Public Sub ShiftValuesByFixedValue(ByVal Shift As Double)
            For i As Integer = 0 To Me._Values.Count - 1 Step 1
                Me._Values(i) += Shift
            Next
        End Sub

        ''' <summary>
        ''' Multiplies each value a given double
        ''' </summary>
        Public Sub MultiplyValuesByFixedValue(ByVal Multiplier As Double)
            For i As Integer = 0 To Me._Values.Count - 1 Step 1
                Me._Values(i) *= Multiplier
            Next
        End Sub
#End Region

#Region "Statistics on Values"

        ''' <summary>
        ''' Get Maximum Value of this Column.
        ''' Considers just the cropped column range.
        ''' </summary>
        Public Function GetMaximumValueOfColumn(Optional ByVal ConsiderAll As Boolean = False) As Double
            Dim dMax As Double = Double.MinValue
            Dim Values As ReadOnlyCollection(Of Double) = Me.Values(ConsiderAll)
            For Each Val As Double In Values
                If Val > dMax Then dMax = Val
            Next
            Return dMax
        End Function

        ''' <summary>
        ''' Get Maximum Absolute Value of this Column.
        ''' Considers just the cropped column range.
        ''' </summary>
        Public Function GetMaximumAbsoluteValueOfColumn(Optional ByVal ConsiderAll As Boolean = False) As Double
            Dim dMax As Double = 0
            Dim Values As ReadOnlyCollection(Of Double) = Me.Values(ConsiderAll)
            For Each Val As Double In Values
                If Math.Abs(Val) > dMax Then dMax = Math.Abs(Val)
            Next
            Return dMax
        End Function

        ''' <summary>
        ''' Get Minimum Value of this Column.
        ''' Considers just the cropped column range.
        ''' </summary>
        Public Function GetMinimumValueOfColumn(Optional ByVal ConsiderAll As Boolean = False) As Double
            Dim dMin As Double = Double.MaxValue
            Dim Values As ReadOnlyCollection(Of Double) = Me.Values(ConsiderAll)
            For Each Val As Double In Values
                If Val < dMin Then dMin = Val
            Next
            Return dMin
        End Function

        ''' <summary>
        ''' Get Minimum Absolute Value of this Column.
        ''' Considers just the cropped column range.
        ''' </summary>
        Public Function GetMinimumAbsoluteValueOfColumn(Optional ByVal ConsiderAll As Boolean = False) As Double
            Dim dMin As Double = Double.MaxValue
            Dim Values As ReadOnlyCollection(Of Double) = Me.Values(ConsiderAll)
            For Each Val As Double In Values
                If Math.Abs(Val) < dMin Then dMin = Math.Abs(Val)
            Next
            Return dMin
        End Function

        ''' <summary>
        ''' Returns the monotonicity of the values.
        ''' </summary>
        Public Enum Monotonicities
            None
            Rising
            StrictRising
            Falling
            StrictFalling
        End Enum

        ''' <summary>
        ''' Determines, if the values are monoton rising, falling, or non-monoton
        ''' </summary>
        Public ReadOnly Property Monotonicity As Monotonicities
            Get

                Dim CurrentValueArray As ReadOnlyCollection(Of Double) = Me.Values

                If CurrentValueArray.Count <= 0 Then Return Monotonicities.None

                Dim Result As Monotonicities = Monotonicities.StrictRising
                Dim CheckValue As Double = CurrentValueArray(0)

                ' Try find a non-NaN value in the column as the start value.
                Dim j As Integer = 0
                Do While Double.IsNaN(CheckValue) And j < CurrentValueArray.Count
                    CheckValue = CurrentValueArray(j)
                    j += 1
                Loop
                If Double.IsNaN(CheckValue) Then Return Monotonicities.None

                ' Check for monoton rising
                For i As Integer = j + 1 To CurrentValueArray.Count - 1 Step 1
                    If Double.IsNaN(CurrentValueArray(i)) Then Continue For
                    If CurrentValueArray(i) > CheckValue Then
                        ' Strict Step
                        CheckValue = CurrentValueArray(i)
                    ElseIf CurrentValueArray(i) = CheckValue Then
                        ' Ok... at least monoton, but not strict anymore.
                        CheckValue = CurrentValueArray(i)
                        Result = Monotonicities.Rising
                    Else
                        Result = Monotonicities.None
                        Exit For
                    End If
                Next

                ' Check for monoton falling, if not raising
                If Result = Monotonicities.None Then
                    Result = Monotonicities.StrictFalling

                    ' Try find a non-NaN value in the column as the start value.
                    CheckValue = CurrentValueArray(0)
                    j = 0
                    Do While Double.IsNaN(CheckValue) And j < CurrentValueArray.Count
                        CheckValue = CurrentValueArray(j)
                        j += 1
                    Loop
                    If Double.IsNaN(CheckValue) Then Return Monotonicities.None

                    For i As Integer = j + 1 To CurrentValueArray.Count - 1 Step 1
                        If Double.IsNaN(CurrentValueArray(i)) Then Continue For
                        If CurrentValueArray(i) < CheckValue Then
                            ' Strict Step
                            CheckValue = CurrentValueArray(i)
                        ElseIf Me._Values(i) = CheckValue Then
                            ' Ok... at least monoton, but not strict anymore.
                            CheckValue = CurrentValueArray(i)
                            Result = Monotonicities.Falling
                        Else
                            Result = Monotonicities.None
                            Exit For
                        End If
                    Next
                End If

                Return Result
            End Get
        End Property

#End Region

#Region "Search values"

        ''' <summary>
        ''' Returns the first index after which the values are larger, than the valuetocheck.
        ''' Returns -1, if never larger.
        ''' </summary>
        Public Function GetFirstIndexAfterWhichValuesAreLargerThan(ByVal ValueToCheck As Double,
                                                                   Optional ByVal IndexToStartSearching As Integer = 0) As Integer
            If IndexToStartSearching < 0 Then IndexToStartSearching = 0
            If IndexToStartSearching > Me._Values.Count - 1 Then IndexToStartSearching = Me._Values.Count - 1
            For i As Integer = IndexToStartSearching To Me._Values.Count - 1 Step 1
                If Double.IsNaN(Me._Values(i)) Then Continue For
                If ValueToCheck < Me._Values(i) Then Return i
            Next
            Return -1
        End Function

        ''' <summary>
        ''' Returns the first index after which the values are smaller, than the valuetocheck.
        ''' Returns -1, if never smaller.
        ''' </summary>
        Public Function GetFirstIndexAfterWhichValuesAreSmallerThan(ByVal ValueToCheck As Double,
                                                                    Optional ByVal IndexToStartSearching As Integer = 0) As Integer
            If IndexToStartSearching < 0 Then IndexToStartSearching = 0
            If IndexToStartSearching > Me._Values.Count - 1 Then IndexToStartSearching = Me._Values.Count - 1
            For i As Integer = IndexToStartSearching To Me._Values.Count - 1 Step 1
                If Double.IsNaN(Me._Values(i)) Then Continue For
                If ValueToCheck > Me._Values(i) Then Return i
            Next
            Return -1
        End Function

#End Region

#Region "Data Extraction"
        ''' <summary>
        ''' Removes the values that don't lie in the selected Value-Range.
        ''' Replaces them by Double.NaN.
        ''' If Lower > Upper the limits are exchanged!
        ''' </summary>
        Public Sub SetValuesOutsideRangeToNaN(ByVal LowerLimitIncl As Double,
                                              ByVal UpperLimitIncl As Double)
            If LowerLimitIncl > UpperLimitIncl Then
                Dim TMP As Double = LowerLimitIncl
                LowerLimitIncl = UpperLimitIncl
                UpperLimitIncl = TMP
            End If

            ' Setup the crop list.
            Dim CropIndices As New List(Of Integer)

            ' Try find the crop limits.
            For i As Integer = 0 To Me._Values.Count - 1 Step 1
                If Double.IsNaN(Me._Values(i)) Then
                    CropIndices.Add(i)
                ElseIf Me._Values(i) > UpperLimitIncl Or Me._Values(i) < LowerLimitIncl Then
                    CropIndices.Add(i)
                End If
            Next
        End Sub

        ''' <summary>
        ''' Removes the values that don't lie in the selected Value-Range.
        ''' Replaces them by Double.NaN.
        ''' If Lower > Upper the limits are exchanged!
        ''' </summary>
        Public Function CropValues(ByVal MinIndexIncl As Integer,
                                   ByVal MaxIndexIncl As Integer) As cSpectroscopyTable.DataColumn.CropInformation
            If MinIndexIncl > MaxIndexIncl Then
                Dim TMP As Integer = MinIndexIncl
                MinIndexIncl = MaxIndexIncl
                MaxIndexIncl = TMP
            End If

            ' Create crop information
            Dim CI As New cSpectroscopyTable.DataColumn.CropInformation(MinIndexIncl, MaxIndexIncl)
            Me.CurrentCropInformation = CI
            Return CI

        End Function

#End Region

#Region "Get column without cropped NaN numbers"
        ''' <summary>
        ''' Returns the current column without those values, where
        ''' the given source column has Double.IsNaN
        ''' </summary>
        Public Function GetColumnWithoutValuesWhereSourceColumnIsNaN(ByRef SourceColumn As DataColumn) As DataColumn
            If Me.Values.Count <> SourceColumn.Values.Count Then
                Throw New Exception("Error: Columns have to be of the same length")
            End If

            Dim SourceColumnValues As ReadOnlyCollection(Of Double) = SourceColumn.Values
            Dim CopyCol As DataColumn = Me.GetCopy
            Dim CopyColValues As List(Of Double) = CopyCol.Values(True).ToList

            Dim RemoveIndices As New List(Of Integer)
            For i As Integer = 0 To SourceColumnValues.Count - 1 Step 1
                If Double.IsNaN(SourceColumnValues(i)) Then
                    RemoveIndices.Add(i)
                End If
            Next
            If RemoveIndices.Count > 0 Then
                For i As Integer = RemoveIndices.Count - 1 To 0 Step -1
                    CopyColValues.RemoveAt(RemoveIndices(i))
                Next
            End If
            CopyCol.SetValueList(CopyColValues)
            RemoveIndices.Clear()
            Return CopyCol
        End Function

        ''' <summary>
        ''' Returns the current column without NaN-values.
        ''' </summary>
        Public Function GetValuesWithoutNaNValues() As List(Of Double)
            Dim Values As List(Of Double) = Me.Values.ToList
            Values.RemoveAll(AddressOf Double.IsNaN)
            Return Values
        End Function

#End Region

#Region "Hard-Copy of a Column"
        ''' <summary>
        ''' Returns an exact Copy of a DataColumn
        ''' </summary>
        Public Function GetCopy() As DataColumn
            Dim oCol As New cSpectroscopyTable.DataColumn
            With Me
                oCol.Name = .Name
                oCol.UnitType = .UnitType
                oCol.UnitSymbol = .UnitSymbol
                oCol.IsSpectraFoxGenerated = .IsSpectraFoxGenerated
                oCol.CurrentCropInformation = .CurrentCropInformation.GetCopy
                Dim Values As ReadOnlyCollection(Of Double) = .Values(True)
                For Each Val As Double In Values
                    oCol.AddValueToColumn(Val)
                Next
            End With
            Return oCol
        End Function
#End Region

#Region "Structure for Storage of Crop-Information"

        ''' <summary>
        ''' This structure represents the crop information necessary to describe a cropped column.
        ''' </summary>
        Public Structure CropInformation

#Region "Crop-Information"

            Private _MaxIndexIncl As Integer
            Private _MinIndexIncl As Integer

            ''' <summary>
            ''' Maximum index, that should be included in the cropped data.
            ''' </summary>
            Public ReadOnly Property MaxIndexIncl As Integer
                Get
                    Return Me._MaxIndexIncl
                End Get
            End Property

            ''' <summary>
            ''' Minimum index, that should be included in the cropped data.
            ''' </summary>
            Public ReadOnly Property MinIndexIncl As Integer
                Get
                    Return Me._MinIndexIncl
                End Get
            End Property

#End Region

#Region "Operators"

            ''' <summary>
            ''' Compares two Crop-Informations
            ''' </summary>
            <DebuggerStepThrough>
            Public Shared Operator =(ByVal A As CropInformation, ByVal B As CropInformation) As Boolean
                If A.MaxIndexIncl = B.MaxIndexIncl And A.MinIndexIncl = B.MinIndexIncl Then
                    Return True
                Else
                    Return False
                End If
            End Operator

            ''' <summary>
            ''' Compares two Crop-Informations
            ''' </summary>
            <DebuggerStepThrough>
            Public Shared Operator <>(ByVal A As CropInformation, ByVal B As CropInformation) As Boolean
                Return Not A = B
            End Operator

#End Region

#Region "Constructor and destructor"
            ''' <summary>
            ''' Creates a crop information.
            ''' </summary>
            Public Sub New(Optional ByVal MinIndexIncl As Integer = -1, Optional ByVal MaxIndexIncl As Integer = -1)
                Me._MinIndexIncl = MinIndexIncl
                Me._MaxIndexIncl = MaxIndexIncl
            End Sub
#End Region

#Region "Cloning and copying"

            ''' <summary>
            ''' Returns a hard-copy of this crop informations
            ''' </summary>
            Public Function GetCopy() As CropInformation
                Return New CropInformation(Me._MinIndexIncl, Me.MaxIndexIncl)
            End Function

#End Region

        End Structure

#End Region

    End Class
#End Region

#Region "Properties"

    ''' <summary>
    ''' Variable that saves the FileObject-Reference from which the ScanImage was created.
    ''' </summary>
    Public BaseFileObject As cFileObject

    ''' <summary>
    ''' Tells the Program, if the Table was created at runtime,
    ''' or it has its source in a Spectroscopy-File.
    ''' </summary>
    Public _bFileExists As Boolean = False

    ' Properties
    <DescriptionAttribute("Shows the full path of the data file."), _
        CategoryAttribute("File Informations"), _
        ReadOnlyAttribute(True)>
    Public Property FullFileName As String = ""

    ''' <summary>
    ''' Returns only the File-Name without path, but with extension.
    ''' </summary>
    Public ReadOnly Property FileNameWithoutPath As String
        Get
            Return System.IO.Path.GetFileName(Me.FullFileName)
        End Get
    End Property

    ''' <summary>
    ''' Returns only the File-Name without extension.
    ''' </summary>
    Public ReadOnly Property FileNameWithoutPathAndExtension As String
        Get
            Return System.IO.Path.GetFileNameWithoutExtension(Me.FullFileName)
        End Get
    End Property

    ''' <summary>
    ''' Variable that stores a custom given name for that scan-image.
    ''' For normal images it is empty.
    ''' </summary>
    Protected _DisplayName As String = String.Empty

    ''' <summary>
    ''' Returns a name to show it in plots, etc.
    ''' Usually it returns the FileNameWithoutPath, but if
    ''' the <code>_DisplayName</code> is set, it will display this variable.
    ''' </summary>
    Public Property DisplayName As String
        Get
            If Me._DisplayName <> String.Empty Then
                Return Me._DisplayName
            Else
                Return Me.FileNameWithoutPath
            End If
        End Get
        Set(value As String)
            Me._DisplayName = value.Trim
        End Set
    End Property

    ''' <summary>
    ''' List that stores KeyValuePairs of properties, that are unimportant for SpectraFox.
    ''' Here all interpreted properties in the file headers are written to,
    ''' that are not identified by SpectraFox.
    ''' </summary>
    Protected _PropertyList As List(Of KeyValuePair(Of String, String))

    ''' <summary>
    ''' List that stores KeyValuePairs of properties, that are unimportant for SpectraFox.
    ''' Here all interpreted properties in the file headers are written to,
    ''' that are not identified by SpectraFox.
    ''' </summary>
    Public ReadOnly Property PropertyList As List(Of KeyValuePair(Of String, String))
        Get
            Return Me._PropertyList
        End Get
    End Property


#Region "Basic properties"

    <DescriptionAttribute("Shows the date the spectrum was recorded."), _
        CategoryAttribute("General Spectrum Properties"), _
        ReadOnlyAttribute(True)>
    Public Property RecordDate As Date

    <DescriptionAttribute("Shows the time that the program waits before data acuisition after the bias was changed."), _
        CategoryAttribute("General Spectrum Properties"), _
        ReadOnlyAttribute(True)>
    Public Property SettlingTime_s As Double

    <DescriptionAttribute("Shows the integration time over one data point."), _
       CategoryAttribute("General Spectrum Properties"), _
       ReadOnlyAttribute(True)>
    Public Property IntegrationTime_s As Double


    <DescriptionAttribute("Shows if the Feedback was turned off during spectroscopy acuisition."), _
      CategoryAttribute("Spectrum Settings"), _
      ReadOnlyAttribute(True)>
    Public Property FeedbackOff As Boolean

    <DescriptionAttribute("Shows the Bias at which the Feedback got opened to start the Spectrum."), _
      CategoryAttribute("_ Bias Spectroscopy Settings"), _
      ReadOnlyAttribute(True)>
    Public Property FeedbackOpenBias_V As Double

    <DescriptionAttribute("Shows the Current at which the Feedback got opened at the beginning of the Spectrum."), _
      CategoryAttribute("_ Bias Spectroscopy Settings"), _
      ReadOnlyAttribute(True)>
    Public Property FeedbackOpenCurrent_A As Double

    <DescriptionAttribute("Comment entered by the user for the Spectrum."), _
      CategoryAttribute("_ Comment"), _
      ReadOnlyAttribute(True)>
    Public Property Comment As String

    <DescriptionAttribute("Shows the Calibration of the Bias used in this Spectrum."), _
      CategoryAttribute("Calibration"), _
      ReadOnlyAttribute(True)>
    Public Property Bias_Calibration_V_V As Double

    <DescriptionAttribute("Shows the offset in the calibration of the Bias."), _
      CategoryAttribute("Calibration"), _
      ReadOnlyAttribute(True)>
    Public Property Bias_OffSet_V As Double


    <DescriptionAttribute("Shows the Bias-Value at the beginning of the Spectrum."), _
      CategoryAttribute("_ Bias Spectroscopy Settings"), _
      ReadOnlyAttribute(True)>
    Public Property BiasSpec_SweepStart_V As Double

    <DescriptionAttribute("Shows the Bias-Value at the end of the Spectrum."), _
      CategoryAttribute("_ Bias Spectroscopy Settings"), _
      ReadOnlyAttribute(True)>
    Public Property BiasSpec_SweepEnd_V As Double


    <DescriptionAttribute("Shows the Number of Data Points in the Spectrum."), _
      CategoryAttribute("Spectrum Settings"), _
      ReadOnlyAttribute(True)>
    Public Property MeasurementPoints As Integer

    <DescriptionAttribute("Shows the Z-Average-Time."), _
      CategoryAttribute("Spectrum Settings"), _
      ReadOnlyAttribute(True)>
    Public Property Z_Avg_Time_s As Double

    <DescriptionAttribute("Shows offset of the controller-hold point before taking a spectrum."), _
      CategoryAttribute("Spectrum Settings"), _
      ReadOnlyAttribute(True)>
    Public Property Z_Offset As Double


    <DescriptionAttribute("Shows if the Spectrum contains forward and backward sweep of the data."), _
      CategoryAttribute("Initial Spectrum Settings"), _
      ReadOnlyAttribute(True)>
    Public Property Backward_Sweep As Boolean

    <DescriptionAttribute("Shows the number of sweeps recorded in the spectrum."), _
      CategoryAttribute("Initial Spectrum Settings"), _
      ReadOnlyAttribute(True)>
    Public Property NumberOfSweeps As Integer


    <DescriptionAttribute("Shows the position at which the spectrum is recorded."),
     CategoryAttribute("Location"),
     ReadOnlyAttribute(True)>
    Public Property Location_X As Double

    <DescriptionAttribute("Shows the position at which the spectrum is recorded."),
     CategoryAttribute("Location"),
     ReadOnlyAttribute(True)>
    Public Property Location_Y As Double

    <DescriptionAttribute("Shows the position at which the spectrum is recorded."),
     CategoryAttribute("Location"),
     ReadOnlyAttribute(True)>
    Public Property Location_Z As Double

    <DescriptionAttribute("Shows the position at which the spectrum is recorded."),
     CategoryAttribute("Location"),
     ReadOnlyAttribute(True)>
    Public ReadOnly Property Location As cNumericalMethods.Point3D
        Get
            Return New cNumericalMethods.Point3D(Me.Location_X, Me.Location_Y, Me.Location_Z)
        End Get
    End Property

    <DescriptionAttribute("Distance the contoller sweeps the Z-Piezo."), _
      CategoryAttribute("_ Z-Spectroscopy Settings"), _
      ReadOnlyAttribute(True)>
    Public Property Z_Sweep_Distance As Double

    <DescriptionAttribute("Bias during the Z-Spectroscopy."), _
      CategoryAttribute("_ Z-Spectroscopy Settings"), _
      ReadOnlyAttribute(True)>
    Public Property Z_Spectroscopy_Bias_V As Double

#End Region

#Region "Current Settings"

    <DescriptionAttribute("Current at which the spectrum is started."), _
      CategoryAttribute("_ Current Settings"), _
      ReadOnlyAttribute(True)>
    Public Property Curr_Current As Double

    <DescriptionAttribute("Calibration of the current amplifier."), _
      CategoryAttribute("_ Current Settings"), _
      ReadOnlyAttribute(True)>
    Public Property Curr_Calibration As Double

    <DescriptionAttribute("Offset set for the current amplifier."), _
      CategoryAttribute("_ Current Settings"), _
      ReadOnlyAttribute(True)>
    Public Property Curr_Offset As Double

    <DescriptionAttribute("Applied gain in the current amplifier."), _
      CategoryAttribute("_ Current Settings"),
      ReadOnlyAttribute(True)>
    Public Property Curr_Gain As String

#End Region

#Region "Z-Controller Settings"

    <DescriptionAttribute("Last value of the Z controller value."), _
    CategoryAttribute("Z-Controller"), _
    ReadOnlyAttribute(True)>
    Public Property ZController_Z As Double

    <DescriptionAttribute("Name of the selected controller."), _
    CategoryAttribute("Z-Controller"), _
    ReadOnlyAttribute(True)>
    Public Property ZController_ControllerName As String

    <DescriptionAttribute("Status of the controller."), _
    CategoryAttribute("Z-Controller"), _
    ReadOnlyAttribute(True)>
    Public Property ZController_ControllerStatus As Boolean

    <DescriptionAttribute("Setpoint of the contoller."), _
    CategoryAttribute("Z-Controller"), _
    ReadOnlyAttribute(True)>
    Public Property ZController_Setpoint As Double

    <DescriptionAttribute("Unit in which the setpoint is given."), _
    CategoryAttribute("Z-Controller"), _
    ReadOnlyAttribute(True)>
    Public Property ZController_SetpointUnit As String

    <DescriptionAttribute("Proportional gain value."), _
    CategoryAttribute("Z-Controller"), _
    ReadOnlyAttribute(True)>
    Public Property ZController_PGain As Double

    <DescriptionAttribute("Integral gain value."), _
    CategoryAttribute("Z-Controller"), _
    ReadOnlyAttribute(True)>
    Public Property ZController_IGain As Double

    <DescriptionAttribute("Time constant of the integral gain."), _
    CategoryAttribute("Z-Controller"), _
    ReadOnlyAttribute(True)>
    Public Property ZController_TimeConst As Double

    <DescriptionAttribute("Height the tip gets lifted after switching off the Z-controller."), _
    CategoryAttribute("Z-Controller"), _
    ReadOnlyAttribute(True)>
    Public Property ZController_TipLift As Double

    <DescriptionAttribute("Delay to average the position before switching off the controller."), _
    CategoryAttribute("Z-Controller"), _
    ReadOnlyAttribute(True)>
    Public Property ZController_SwitchOffDelay As Double

#End Region

#Region "Temperature"

    <DescriptionAttribute("Temperature during the measurement."), _
      CategoryAttribute("_ Temperature"), _
      ReadOnlyAttribute(True)>
    Public Property Temperature As Double

#End Region

#Region "Oscillator Control"

    <DescriptionAttribute("Input calibration."), _
      CategoryAttribute("_ Oscillator Control Settings"), _
      ReadOnlyAttribute(True)>
    Public Property OscCntrl_InputCalibration As Double

    <DescriptionAttribute("Input range."), _
      CategoryAttribute("_ Oscillator Control Settings"), _
      ReadOnlyAttribute(True)>
    Public Property OscCntrl_InputRange As Double

    <DescriptionAttribute("Center frequency."), _
      CategoryAttribute("_ Oscillator Control Settings"), _
      ReadOnlyAttribute(True)>
    Public Property OscCntrl_CenterFrequency As Double

    <DescriptionAttribute("Range."), _
      CategoryAttribute("_ Oscillator Control Settings"), _
      ReadOnlyAttribute(True)>
    Public Property OscCntrl_Range As Double

    <DescriptionAttribute("Reference phase."), _
      CategoryAttribute("_ Oscillator Control Settings"), _
      ReadOnlyAttribute(True)>
    Public Property OscCntrl_ReferencePhase As Double

    <DescriptionAttribute("Cutoff frequency."), _
      CategoryAttribute("_ Oscillator Control Settings"), _
      ReadOnlyAttribute(True)>
    Public Property OscCntrl_CutOffFrequency As Double

    <DescriptionAttribute("Harmonic"), _
      CategoryAttribute("_ Oscillator Control Settings"), _
      ReadOnlyAttribute(True)>
    Public Property OscCntrl_Harmonic As Integer

    <DescriptionAttribute("Phase controller: proportional gain."), _
      CategoryAttribute("_ Oscillator Control Settings"), _
      ReadOnlyAttribute(True)>
    Public Property OscCntrl_PhasePGain As Double

    <DescriptionAttribute("Phase controller: integral gain."), _
      CategoryAttribute("_ Oscillator Control Settings"), _
      ReadOnlyAttribute(True)>
    Public Property OscCntrl_PhaseIGain As Double

    <DescriptionAttribute("Phase controller: status."), _
      CategoryAttribute("_ Oscillator Control Settings"), _
      ReadOnlyAttribute(True)>
    Public Property OscCntrl_PhaseControllerStatus As Boolean

    <DescriptionAttribute("Frequency shift."), _
      CategoryAttribute("_ Oscillator Control Settings"), _
      ReadOnlyAttribute(True)>
    Public Property OscCntrl_FrequencyShift As Double

    <DescriptionAttribute("Amplitude controller: setpoin."), _
      CategoryAttribute("_ Oscillator Control Settings"), _
      ReadOnlyAttribute(True)>
    Public Property OscCntrl_AmplitudeSetpoint As Double

    <DescriptionAttribute("Amplitude controller: proportional gain."), _
      CategoryAttribute("_ Oscillator Control Settings"), _
      ReadOnlyAttribute(True)>
    Public Property OscCntrl_AmplitudePGain As Double

    <DescriptionAttribute("Amplitude controller: integral gain."), _
      CategoryAttribute("_ Oscillator Control Settings"), _
      ReadOnlyAttribute(True)>
    Public Property OscCntrl_AmplitudeIGain As Double

    <DescriptionAttribute("Amplitude controller status."), _
      CategoryAttribute("_ Oscillator Control Settings"), _
      ReadOnlyAttribute(True)>
    Public Property OscCntrl_AmplitudeControllerStatus As Boolean

    <DescriptionAttribute("Excitation."), _
      CategoryAttribute("_ Oscillator Control Settings"), _
      ReadOnlyAttribute(True)>
    Public Property OscCntrl_Excitation As Double

    <DescriptionAttribute("PLL setup: Q-factor."), _
      CategoryAttribute("_ Oscillator Control Settings"), _
      ReadOnlyAttribute(True)>
    Public Property OscCntrl_PLLSetup_QFactor As Double

    <DescriptionAttribute("PLL setup: demodulation bandwidth."), _
      CategoryAttribute("_ Oscillator Control Settings"), _
      ReadOnlyAttribute(True)>
    Public Property OscCntrl_PLLSetup_DemodBandwidthAmplitude As Double

    <DescriptionAttribute("PLL setup: demodulation bandwidth."), _
      CategoryAttribute("_ Oscillator Control Settings"), _
      ReadOnlyAttribute(True)>
    Public Property OscCntrl_PLLSetup_DemodBandwidthPhase As Double

    <DescriptionAttribute("PLL setup: amplitude to excitation."), _
      CategoryAttribute("_ Oscillator Control Settings"), _
      ReadOnlyAttribute(True)>
    Public Property OscCntrl_PLLSetup_AmplitudeToExcitation As Double

    <DescriptionAttribute("Output divider."), _
      CategoryAttribute("_ Oscillator Control Settings"), _
      ReadOnlyAttribute(True)>
    Public Property OscCntrl_OutputDivider As Double

    <DescriptionAttribute("Output off."), _
      CategoryAttribute("_ Oscillator Control Settings"), _
      ReadOnlyAttribute(True)>
    Public Property OscCntrl_OutputOff As Boolean

    <DescriptionAttribute("Output adder."), _
      CategoryAttribute("_ Oscillator Control Settings"), _
      ReadOnlyAttribute(True)>
    Public Property OscCntrl_OutputAdd As Boolean

    <DescriptionAttribute("Input divider ratio."), _
      CategoryAttribute("_ Oscillator Control Settings"), _
      ReadOnlyAttribute(True)>
    Public Property OscCntrl_Input1To10 As Boolean

    <DescriptionAttribute("Differential Input."), _
      CategoryAttribute("_ Oscillator Control Settings"), _
      ReadOnlyAttribute(True)>
    Public Property OscCntrl_DifferentialInput As Boolean

#End Region

    ''' <summary>
    ''' Contains all the Columns of the Spectroscopy-Table
    ''' </summary>
    Public Property Columns As New Dictionary(Of String, DataColumn)

    ''' <summary>
    ''' Saves the length of the longest DataColumn saved in this
    ''' Object, to adapt the length of newly added columns, if their count is smaller,
    ''' or to adapt the count of all present columns, if the added count is larger.
    ''' </summary>
    Private CurrentColumnLength As Integer = 0

    ''' <summary>
    ''' This array stores all properties, that are informative for the user,
    ''' but unimportant for the software to work.
    ''' </summary>
    Protected _GeneralPropertyArray As New List(Of KeyValuePair(Of String, String))

    ''' <summary>
    ''' This array stores all properties, that are informative for the user,
    ''' but unimportant for the software to work.
    ''' </summary>
    <DescriptionAttribute("Properties extracted from the file."),
        CategoryAttribute("General Properties"),
        ReadOnlyAttribute(True)>
    Public ReadOnly Property GeneralPropertyArray As ReadOnlyCollection(Of KeyValuePair(Of String, String))
        Get
            Return New ReadOnlyCollection(Of KeyValuePair(Of String, String))(Me._GeneralPropertyArray)
        End Get
    End Property

    ''' <summary>
    ''' Adds a general property attribute to the property array.
    ''' </summary>
    Public Sub AddGeneralProperty(ByVal Key As String, ByVal Value As String)
        Me._GeneralPropertyArray.Add(New KeyValuePair(Of String, String)(Key, Value))
    End Sub

#End Region

#Region "Column Editing"

    ''' <summary>
    ''' Returns the DataColumn given by the name
    ''' </summary>
    Public Function Column(ByVal Name As String) As DataColumn
        Return Me._Columns(Name)
    End Function

    ''' <summary>
    ''' Checks, if a Column exists!
    ''' </summary>
    Public Function ColumnExists(ByVal Name As String) As Boolean
        Return Me._Columns.ContainsKey(Name)
    End Function

    ''' <summary>
    ''' Adds a new Column to the Spectroscopy-Table,
    ''' but does not store it in the file-object.
    ''' So it is not kept after a reloading!
    ''' Returns the new Column-Index
    ''' </summary>
    Public Function AddNonPersistentColumn(ByRef Column As DataColumn) As Boolean
        ' Check, if an adaption of the column-count is necessary.
        ' It takes care, that only columns of the same length are added.
        If Me.CurrentColumnLength = 0 And Me._Columns.Count = 0 Then
            ' First Column added!
            Me.CurrentColumnLength = Column.Values(True).Count
        Else
            Dim LengthDifference As Integer = Math.Abs(Me.CurrentColumnLength - Column.Values(True).Count)
            ' Columns already exist in the SpectroscopyTable
            If LengthDifference > 0 Then
                Throw New ArgumentException("SpectroscopyTable: Column of unequal length added. Difference: " & LengthDifference)
            End If
        End If

        ' Check, if the name already exists, if yes, then add a number in the end.
        Dim iCounter As Integer = 2
        Dim sNameWithoutCounter As String = Column.Name
        Do While CheckIfColumnNameAlreadyExists(Me._Columns, Column.Name)
            Column.Name = sNameWithoutCounter & " (" & iCounter & ")"
            iCounter += 1
        Loop

        ' Add the Column to the Dictionary.
        Me._Columns.Add(Column.Name, Column)

        Return True
    End Function

    ''' <summary>
    ''' Checks, if the ColumnName is already present the given number of times in the ColumnList
    ''' </summary>
    Public Shared Function CheckIfColumnNameAlreadyExists(ByRef ListOfColumns As Dictionary(Of String, DataColumn),
                                                          ByVal Name As String) As Boolean
        Return ListOfColumns.ContainsKey(Name)
    End Function

    ''' <summary>
    ''' Copy Column
    ''' </summary>
    Public Function CopyColumn(ByVal Name As String) As cSpectroscopyTable.DataColumn
        ' Check, if Column Exists, otherwise create new
        If Me.ColumnExists(Name) Then
            Return Me.Column(Name).GetCopy
        Else
            Return Nothing
        End If
    End Function

    ''' <summary>
    ''' Returns the list of all Column-Objects.
    ''' </summary>
    Public Function GetColumnList() As Dictionary(Of String, DataColumn)
        Return Me._Columns
    End Function

    ''' <summary>
    ''' Returns the list of all column values.
    ''' </summary>
    Public Function GetColumnValueList(Optional ByVal ConsiderAll As Boolean = False) As Dictionary(Of String, ReadOnlyCollection(Of Double))
        Dim L As New Dictionary(Of String, ReadOnlyCollection(Of Double))(Me._Columns.Count)
        For Each C As DataColumn In Me._Columns.Values
            L.Add(C.Name, C.Values(ConsiderAll))
        Next
        Return L
    End Function

    ''' <summary>
    ''' Returns the saved DataColumn-List of Names.
    ''' </summary>
    Public Function GetColumnNameList() As List(Of String)
        Return Me._Columns.Keys.ToList
    End Function

    ''' <summary>
    ''' Sets the CropInformation for the whole spectroscopy-table.
    ''' </summary>
    Public Sub SetCropInformation(ByRef CropInformation As cSpectroscopyTable.DataColumn.CropInformation)
        For Each Column As cSpectroscopyTable.DataColumn In Me._Columns.Values
            Column.CurrentCropInformation = CropInformation
        Next
    End Sub
#End Region

    '##################################################################################
    '
    '                           SHARED FUNCTIONS
    '
    '##################################################################################

#Region "Shared Functions"
    ''' <summary>
    ''' Takes several spectra and returns all columns that the files have in common.
    ''' Returns a list of all ColumnNames that are in common.
    ''' </summary>
    Public Shared Function GetCommonColumns(ByRef SpectroscopyTableList As List(Of cSpectroscopyTable)) As List(Of String)
        Dim ListOfCommonColumnNames As New List(Of String)
        Dim ListOfColumnIndizesInSpectroscopyTables As New Dictionary(Of String, List(Of Integer))


        ' List to count the columns by Name to determine all Common Columns
        Dim ListOfCommonColumns As New Dictionary(Of String, Integer)

        ' Run through all Spectroscopy-Tables and increase
        ' the presence-counter for each Column in the Spectroscopy-File
        For i As Integer = 0 To SpectroscopyTableList.Count - 1 Step 1
            For Each ColumnName As String In SpectroscopyTableList(i).GetColumnNameList
                ' Save Column in the Counter-List
                If ListOfCommonColumns.ContainsKey(ColumnName) Then
                    ListOfCommonColumns(ColumnName) += 1
                Else
                    ListOfCommonColumns.Add(ColumnName, 1)
                End If
            Next
        Next

        ' Now extract all Column-Names into the Combobox, that exist in each Spectroscopy-Table
        For Each Col As KeyValuePair(Of String, Integer) In ListOfCommonColumns
            If Col.Value = SpectroscopyTableList.Count Then
                ListOfCommonColumnNames.Add(Col.Key)
            End If
        Next

        Return ListOfCommonColumnNames
    End Function
#End Region

End Class
